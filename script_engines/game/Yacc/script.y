%{   /* declarations */

//
// DO NOT EDIT THIS FILE. IT IS AUTOGENERATED
// BY THE "YAY" (YET ANOTHER YACC) PROGRAM.
// TO EDIT THE CODE PLEASE REFER TO THE
// SCRIPT.Y FILE IN THE \YACC FOLDER.
//

#include "stdafx.h"
#include "script.h"

#pragma warning( disable : 4068 )
//#define YYSYNC 1

LPCTSTR tokennames[] = {
 _T("BEGIN"),_T("END"),_T("INCLUDE"),_T("CONST"),
 _T("HERO"),_T("PLAYER"),_T("ROOM"),_T("PROPS"),_T("ITEMS"),
 _T("STATICOBJECTS"),_T("OBJECTS"),_T("EXITS"),
 _T("ANIM"),_T("OBJ"),_T("OBJECT"),_T("ITEM"),_T("EXIT"),
 _T("ID"),_T("NAME"),_T("DESCRIPTION"),_T("SURFACE"),
 _T("EVENTCODE"),_T("STATECODE"),
 _T("FRAME"),_T("RATE"),_T("FREQ"),_T("REPEAT"), _T("VELOCITY"), _T("LOOP"),
 _T("STARTPOS"),_T("STARTROOM"),_T("GOTO"),
 NULL
};

typedef struct {
	long val;
	char *cstr;
} YYSTYPE;


%}

%token BEGIN END INCLUDE CONSTANT
%token HERO PLAYER ROOM PROPS ITEMS
%token STATICOBJECTS OBJECTS EXITS
%token ANIM OBJ OBJECT ITEM EXIT
%token ID NAME DESCRIPTION SURFACE
%token EVENTCODE STATECODE
%token FRAME RATE FREQ REPEAT VELOCITY LOOP
%token STARTPOS STARTROOM GOTO
%token NAME STRING NUMBER

%left '+' '-'
%left '*' '%'

%type <cstr> STRING
%type <cstr> NAME
%type <val> NUMBER
%type <val> intexp


%%

script
	: elementlist;

elementlist
	: elementlist element
	| /* Nothing */
	;

element
	: BEGIN ROOM room_def_list END ROOM
	{
		ASSERT_VALID(s_ptr);
		ASSERT_VALID(s_ptr->m_room);
		s_ptr->m_pGame->m_rooms.Add( s_ptr->m_room );
		s_ptr->m_room = new CG_Room;
		if(s_ptr->m_room==NULL) yyerror("Out of memory");
	}
	| BEGIN PLAYER player_def_list END PLAYER
	{
		ASSERT_VALID(s_ptr);
		ASSERT_VALID(s_ptr->m_player);
		s_ptr->m_pGame->m_chars.Add( s_ptr->m_player );
		s_ptr->m_player = new CG_Character;
		if(s_ptr->m_player==NULL) yyerror("Out of memory");
	}
	| BEGIN HERO hero_def_list END HERO
	{
		static BOOL bDefined = FALSE;
		if( bDefined ) yyerror(_T("Hero already defined!"));
		bDefined = TRUE;
		ASSERT_VALID(s_ptr);
		ASSERT_VALID(s_ptr->m_hero);
		s_ptr->m_pGame->m_chars.Add( s_ptr->m_hero );
		s_ptr->m_pGame->m_current_hero = s_ptr->m_hero;
		s_ptr->m_hero = new CG_Hero;
		if(s_ptr->m_hero==NULL) yyerror("Out of memory");
	}
	| BEGIN PROPS items_def_list END PROPS
	| const_def
	| include
	| error
	;

include
	: INCLUDE STRING
	{
		ASSERT_VALID(s_ptr);
		CString s($2);
		s = KfxLocateFile(s);
		if( s.IsEmpty() ) s = BfxGetFilePath(s_ptr->m_sFilename) + CString($2);
		s_ptr->ProcessFile(s);
		yychar = -1; // this triggers continuing the old parse-tree
	}
	;


const_def
	: CONSTANT NAME '=' NUMBER
	{
		ASSERT_VALID(s_ptr);
		s_ptr->m_pGame->AddConstant($2,$4);
	}
	;


/* -------------- */
/* ---  ROOM  --- */
/* -------------- */

room_def_list
	: room_item
	| room_item room_def_list
	;

room_item
	: NAME STRING { s_ptr->m_room->m_sName = $2; }
	| DESCRIPTION STRING { s_ptr->m_room->m_sDescription = $2; }
	| SURFACE STRING { s_ptr->m_room->m_sSurfaceName = $2; }
	| BEGIN STATICOBJECTS room_static_def_list END STATICOBJECTS  
	| BEGIN OBJECTS room_object_def_list END OBJECTS
	| BEGIN EXITS room_exit_def_list END EXITS
	;

room_static_def_list
	: room_static_item
	| room_static_item room_static_def_list
	;

room_static_item
	: OBJ STRING pos
	{ 
		ASSERT_VALID(s_ptr);
		CG_Prop *prop = s_ptr->m_pGame->m_props.Find($2);
		if( prop==NULL ) { yyerror("Room prop not found."); };
		s_ptr->m_roomobj.obj = prop;
		s_ptr->m_roomobj.pos = s_ptr->m_pos;
		s_ptr->m_room->m_staticobjects.Add(s_ptr->m_roomobj);
	}
	;

room_object_def_list
	: room_object_item
	| room_object_item room_object_def_list
	;

room_object_item
	: OBJ STRING pos
	{ 
		ASSERT_VALID(s_ptr);
		CG_Prop *prop = s_ptr->m_pGame->m_props.Find($2);
		s_ptr->m_roomobj.obj = prop;
		s_ptr->m_roomobj.pos = s_ptr->m_pos;
		s_ptr->m_room->m_objects.Add(s_ptr->m_roomobj);
	}
	;

room_exit_def_list
	: room_exit_item
	| room_exit_item room_exit_def_list
	;

room_exit_item
	: EXIT STRING rect pos
	{ 
		ASSERT_VALID(s_ptr);
		s_ptr->m_roomexit.room = $2;
		s_ptr->m_roomexit.exitarea = s_ptr->m_rect;
		s_ptr->m_roomexit.startpos = s_ptr->m_pos;
		s_ptr->m_room->m_exits.Add(s_ptr->m_roomexit);
	}
	;


/* ---------------- */
/* ---  PLAYER  --- */
/* ---------------- */

player_def_list
	: player_item
	| player_item player_def_list
	;

player_item
	: NAME STRING { s_ptr->m_player->m_sName = $2; }
	| DESCRIPTION STRING { s_ptr->m_player->m_sDescription = $2; }
	| VELOCITY intexp { s_ptr->m_player->m_nVelocity = $2; }
	| SURFACE STRING { s_ptr->m_player->m_sSurfaceName = $2; }
	| STARTPOS pos { s_ptr->m_player->m_pos = s_ptr->m_pos; }
	| STARTROOM STRING { s_ptr->m_player->m_sStartRoom = $2; }
	| EVENTCODE STRING { s_ptr->m_player->m_sLinkEventCode = $2; }
	| STATECODE STRING { s_ptr->m_player->m_sLinkStateCode = $2; }
	| BEGIN ANIM player_anim_def_list END ANIM
	{
		s_ptr->m_player->m_nNumAnims++;
	}
	;

player_anim_def_list
	: player_anim_item
	| player_anim_item player_anim_def_list
	;

player_anim_item
	: NAME STRING { CString s($2); s.MakeUpper(); s_ptr->m_player->m_anims[s_ptr->m_player->m_nNumAnims].sName = s; }
	| FREQ intexp { s_ptr->m_player->m_anims[s_ptr->m_player->m_nNumAnims].nFreq = $2; }
	| REPEAT intexp { s_ptr->m_framerepeat = $2; }
	| LOOP intexp { s_ptr->m_framerepeat = $2; }
	| frame_item
	{
		ASSERT_VALID( s_ptr );
		CG_Character *player = s_ptr->m_player;
		ASSERT_VALID(player);
		player->m_anims[player->m_nNumAnims].Frames.Append( s_ptr->m_frames );
	}
	;

/* -------------- */
/* ---  HERO  --- */
/* -------------- */

hero_def_list
	: hero_item
	| hero_item hero_def_list
	;

hero_item
	: NAME STRING { s_ptr->m_hero->m_sName = $2; }
	| DESCRIPTION STRING { s_ptr->m_hero->m_sDescription = $2; }
	| SURFACE STRING { s_ptr->m_hero->m_sSurfaceName = $2; }
	| STARTPOS pos { s_ptr->m_hero->m_pos = s_ptr->m_pos; }
	| STARTROOM STRING { s_ptr->m_hero->m_sStartRoom = $2; }
	| EVENTCODE STRING { s_ptr->m_hero->m_sLinkEventCode = $2; }
	| STATECODE STRING { s_ptr->m_hero->m_sLinkStateCode = $2; }
	| BEGIN ANIM hero_anim_def_list END ANIM
	{
		s_ptr->m_hero->m_nNumAnims++;
	}
	;

hero_anim_def_list
	: hero_anim_item
	| hero_anim_item hero_anim_def_list
	;

hero_anim_item
	: NAME STRING { CString s($2); s.MakeUpper(); s_ptr->m_hero->m_anims[s_ptr->m_hero->m_nNumAnims].sName = s; }
	| FREQ intexp { s_ptr->m_hero->m_anims[s_ptr->m_hero->m_nNumAnims].nFreq = $2; }
	| REPEAT intexp { s_ptr->m_framerepeat = $2; }
	| frame_item
	{
		ASSERT_VALID( s_ptr );
		CG_Character *hero = s_ptr->m_hero;
		ASSERT_VALID(hero);
		hero->m_anims[hero->m_nNumAnims].Frames.Append( s_ptr->m_frames );
	}
	;


/* --------------- */
/* ---  ITEMS  --- */
/* --------------- */

items_def_list
	: items_item
	| items_item items_def_list
	;

items_item
	: SURFACE STRING { CString s($2); s.MakeUpper(); s_ptr->m_sSurfaceName = s; }
	| BEGIN OBJECT object_def_list END OBJECT
	{
		ASSERT_VALID(s_ptr);
		ASSERT_VALID(s_ptr->m_prop);
		s_ptr->m_prop->m_sSurfaceName = s_ptr->m_sSurfaceName;
		s_ptr->m_pGame->m_props.Add( s_ptr->m_prop );
		//
		s_ptr->m_prop = new CG_Prop;
		if(s_ptr->m_prop==NULL) yyerror("Out of memory");
	}
	| BEGIN ITEM item_def_list END ITEM
	{
		ASSERT_VALID(s_ptr);
		ASSERT_VALID(s_ptr->m_item);
		s_ptr->m_item->m_sSurfaceName = s_ptr->m_sSurfaceName;
		s_ptr->m_pGame->m_items.Add(s_ptr->m_item);
		//
		s_ptr->m_item = new CG_Item;
		if(s_ptr->m_item==NULL) yyerror("Out of memory");
	}
	;

object_def_list
	: object_item
	| object_item object_def_list
	;

object_item
	: NAME STRING { s_ptr->m_prop->m_sName = $2; }
	| frame_item { s_ptr->m_prop->m_frames.Append(s_ptr->m_frames); }
	;

item_def_list
	: item_item
	| item_item item_def_list
	;

item_item
	: NAME STRING  { s_ptr->m_item->m_sName = $2; }
	| DESCRIPTION STRING { s_ptr->m_item->m_sDescription = $2; }
	| STARTROOM STRING { s_ptr->m_item->m_sStartRoom = $2; }
	| STARTPOS pos { s_ptr->m_item->m_pos = s_ptr->m_pos; }
	| EVENTCODE STRING { s_ptr->m_item->m_sLinkEventCode = $2; }
	| frame_item { s_ptr->m_item->m_frames.Append(s_ptr->m_frames); }
	;


/* -------------- */
/* ---  MISC  --- */
/* -------------- */

frame_item
	: FRAME rect
	{
		ASSERT_VALID(s_ptr);
		// Construct one or more frames
		// This allows to quickly create multiple horizontal
		// frames...
		s_ptr->m_frames.RemoveAll();
		int w = s_ptr->m_rect.Width();
		while( s_ptr->m_framerepeat-- > 0 ) {
			s_ptr->m_frames.Add( s_ptr->m_rect );
			s_ptr->m_rect.left += w;
			s_ptr->m_rect.right += w;
		};
		// Default back to 1 frame creation
		s_ptr->m_framerepeat = 1;
	}
	;

pos
	: intexp ',' intexp { s_ptr->m_pos = CPoint($1,$3); }
	| '(' intexp ',' intexp ')' { s_ptr->m_pos = CPoint($2,$4); }
	;

rect
	: intexp ',' intexp ',' intexp ',' intexp { s_ptr->m_rect = CRect(CPoint($1,$3),CSize($5,$7)); }
	| '(' intexp ',' intexp ',' intexp ',' intexp ')' { s_ptr->m_rect = CRect(CPoint($2,$4),CSize($6,$8)); }
	;

intexp 
	: '(' intexp ')' { $$ = $2; }
	| intexp '+' intexp { $$ = $1 + $3; }
	| intexp '-' intexp { $$ = $1 - $3; }
	| intexp '*' intexp { $$ = $1 * $3; }
	| intexp '%' intexp { if( $3==0 ) yyerror("Division by zero!"); else $$ = $1 / $3; }
	| NUMBER 
	;

%%


/////////////////////////////////////
// Parser stuff

int yyparse();

CScriptParser *s_ptr;


CScriptParser::CScriptParser()
{
}

CScriptParser::~CScriptParser()
{
}

BOOL CScriptParser::Init(CController *pGame)
{
   s_ptr = this;
   m_pGame = pGame;
   m_UngetChar = 0;
   m_bErrors = FALSE;
   //
   m_room = new CG_Room;
   m_hero = new CG_Hero;
   m_player = new CG_Character;
   m_item = new CG_Item;
   m_prop = new CG_Prop;
   if( m_prop==NULL ) return FALSE; // error: out of memory
   //
   m_framerepeat = 1;
   //
   return TRUE;
};

BOOL CScriptParser::Close()
{
   delete m_room;
   delete m_hero;
   delete m_player;
   delete m_item;
   delete m_prop;
   return TRUE;
};

BOOL CScriptParser::ProcessFile(LPCTSTR Filename)
{
   ASSERT(s_ptr);
   ASSERT(AfxIsValidString(Filename));
   CApp *app = (CApp *)AfxGetApp();
   ASSERT_VALID(app);
   app->m_debug.PrintReplaceLine(_T("Parsing %s"),Filename);

   CStdioFile f, *old_ptr;
   CString s;
   s = KfxLocateFile(Filename);
   TRY
	{
      if( f.Open( s, CFile::modeRead|CFile::typeText )==FALSE ) return FALSE;
      m_sFilename = s;
      old_ptr = f_ptr;
      f_ptr = &f;
      while( yyparse()!=0 ) ;
      f.Close();
      f_ptr = old_ptr;
   }
   CATCH( CFileException, e )
   {
#ifdef _DEBUG
      e->ReportError();
#endif
      f.Abort();
      return FALSE;
   }
   END_CATCH;
   app->m_debug.PrintReplaceLine(_T("Definitions parsed."));
   return !m_bErrors;
};

static short gettoken()
{
   ASSERT_VALID( s_ptr );
   char c;
   if( s_ptr->m_UngetChar!=0 ) { 
      c = s_ptr->m_UngetChar;
      s_ptr->m_UngetChar = 0;
      return c;
   };
   if( s_ptr->f_ptr->Read(&c,1)==FALSE) return EOF;
   switch( c ) {
   case _T('\t'):
   case _T('\r'):
      // Some character are treated as blanks
      c = _T(' ');
      break;
   };
   return c;
};

static char * stringet()
// Get a complete string enclosed in quotes ( the "-char )
// NOTE: A static char-buffer is returned
{
#define MAX_STRING_LEN 256
    ASSERT_VALID( s_ptr );
    static TCHAR str[MAX_STRING_LEN];
    for ( int i=0; i < MAX_STRING_LEN; i++ ) {
        str[i] = (char)gettoken();
        switch( str[i] ) {
        case _T('"'):
        case _T('\n'):
           goto this_is_it;
        };
    }
this_is_it: ;
    str[i] = '\0';  /* mark end of string */
    return str;
}

static char * wordget(TCHAR c)
// Get a word from the file
// NOTE: Keeps a few static buffers which
// are returned
{
#define MAX_VAR_LEN 16
#define MAX_VARS 4
    ASSERT_VALID( s_ptr );
    static TCHAR var[MAX_VARS][MAX_VAR_LEN];
    static short buf = 0;
    // Get next string buffer
    buf = (buf+1) % MAX_VARS;
    // Fill buffer with chars
    var[buf][0] = c;  /* first letter obtained already */
    for ( int i=1; i < MAX_VAR_LEN; i++ ) {
        var[buf][i] = (char)gettoken();
        switch( var[buf][i] ) {
        case _T(' '):
        case _T('\n'):
           // Ignore blanks and new-lines
           goto this_is_it;
        case _T('('):
        case _T(')'):
        case _T(','):
        case _T('+'):
        case _T('-'):
        case _T('%'):
        case _T('*'):
        case _T('='):
           s_ptr->m_UngetChar = var[buf][i];
           goto this_is_it;
        };
    }
this_is_it:
    var[buf][i] = '\0';
    return var[buf];
}

static int yylex()
{
   char c;
   extern YYSTYPE yylval;
get_it: ;
   while ( (c=(char)gettoken()) == ' ' )
        /* skip blanks */;
   switch(c) {
   case _T('\n'):    /* EOL */
       goto get_it;
   case _T(','):    /* comma */
   case _T('('):    /* r paren */
   case _T(')'):    /* l paren */
   case _T('+'):    /* + */
   case _T('-'):    /* - */
   case _T('*'):    /* * */
   case _T('%'):    /* / */
   case _T('='):    /* equal */
       return c;
   case _T('/'):    /* line comment */
      gettoken();
      while( gettoken()!=_T('\n') ) ;
      goto get_it;
   case EOF:     /* end of file */
       return 0 ;
   case _T('"'):     /* start of string */
       yylval.cstr = stringet();
       return STRING;
   default:      /* keyword or name */
      yylval.cstr = wordget(c);
      // Test if it is a constant number
      if(isdigit(c)) {
         yylval.val = _ttol(yylval.cstr);
         return NUMBER;
      }
      // Check the tokens
      LPCTSTR *p = tokennames;
      int i=1;
      while( *p!=NULL  ) {
         if( stricmp( *p, yylval.cstr )==0 ) 
            return i+256; // 256 = YYERRCODE
         p++;
         i++;
      };
      // Is it a constant?
      DWORD tmp_val;
      if( s_ptr->m_pGame->GetConstant(yylval.cstr,tmp_val) ) {
         yylval.val = tmp_val;
         return NUMBER;
      }
      // Nope, none of the above... it's a simple string
      return NAME;
   }
}

static void yyerror(LPCTSTR s)
{
   CApp *app = (CApp *)AfxGetApp();
   ASSERT(s_ptr);
   ASSERT_VALID(app);
   if( !AfxIsValidString(s) ) return;
   app->m_debug.Error(_T("%s.\r\nIn File: '%s'\r\n"),s,s_ptr->m_sFilename);
   s_ptr->m_bErrors = TRUE;
}


/////////////////////////////////////
// Functions

BOOL CScriptParser::Validate()
{
#define ADDOBJ(dst,x) { \
   ASSERT(x); \
   CString tmp(x->m_sName); \
   tmp.MakeUpper(); \
   dst.SetAt( tmp, x ); \
   };

   ASSERT_VALID( m_pGame );
   int i;
   //
   // Add all objects to Global Object Map (gives quick access to ALL names)
   //
   m_pGame->m_objects.RemoveAll();
   for( i=0; i<m_pGame->m_props.GetSize(); i++ ) ADDOBJ(m_pGame->m_objects,m_pGame->m_props[i]);
   for( i=0; i<m_pGame->m_rooms.GetSize(); i++ ) ADDOBJ(m_pGame->m_objects,m_pGame->m_rooms[i]);
   for( i=0; i<m_pGame->m_items.GetSize(); i++ ) ADDOBJ(m_pGame->m_objects,m_pGame->m_items[i]);
   for( i=0; i<m_pGame->m_chars.GetSize(); i++ ) ADDOBJ(m_pGame->m_objects,m_pGame->m_chars[i]);
   m_pGame->m_liveobjects.RemoveAll();
   for( i=0; i<m_pGame->m_chars.GetSize(); i++ ) m_pGame->m_liveobjects.Add(m_pGame->m_chars[i]);
   for( i=0; i<m_pGame->m_items.GetSize(); i++ ) m_pGame->m_liveobjects.Add(m_pGame->m_items[i]);
   //
   // Validate all ROOM references
   //
   for( i=0; i<m_pGame->m_liveobjects.GetSize(); i++ ) {
      CString sName( m_pGame->m_liveobjects[i]->m_sStartRoom );
      CG_ID id = OBJ_NOTVISIBLE;
      if( sName==_T("INVENTORY") ) {
         id = OBJ_INVENTORY;
      }
      else if( !sName.IsEmpty() ) {
         CG_Room *room = m_pGame->m_objects.FindRoom(sName);
         if( room==NULL ) { yyerror("Room not found."); return FALSE; }
         id = room->m_ID;
      }
      m_pGame->m_liveobjects[i]->m_RoomID = id;
   };

   //
   // Set object size (in pixels) for all
   //
   for( i=0; i<m_pGame->m_items.GetSize(); i++ ) {
         CG_Item *item = m_pGame->m_items[i];
         item->m_size = CSize( item->m_frames[0].Width(), item->m_frames[0].Height() );
   };
   for( i=0; i<m_pGame->m_chars.GetSize(); i++ ) {
         CG_Character *player = m_pGame->m_chars[i];
         player->m_size = CSize( player->m_anims[0].Frames[0].Width(), player->m_anims[0].Frames[0].Height() );
   }

   return TRUE;
};


/////////////////////////////////////
// Yacc stuff
