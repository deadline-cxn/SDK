/* D:\Projects\Game\Yacc\yay.exe script.y Parser=script.cpp */
   /* declarations */

//
// DO NOT EDIT THIS FILE. IT IS AUTOGENERATED
// BY THE "YAY" (YET ANOTHER YACC) PROGRAM.
// TO EDIT THE CODE PLEASE REFER TO THE
// SCRIPT.Y FILE IN THE \YACC FOLDER.
//

#include "stdafx.h"
#include "script.h"

#pragma warning( disable : 4068 )
//#define YYSYNC 1

LPCTSTR tokennames[] = {
 _T("BEGIN"),_T("END"),_T("INCLUDE"),_T("CONST"),
 _T("HERO"),_T("PLAYER"),_T("ROOM"),_T("PROPS"),_T("ITEMS"),
 _T("STATICOBJECTS"),_T("OBJECTS"),_T("EXITS"),
 _T("ANIM"),_T("OBJ"),_T("OBJECT"),_T("ITEM"),_T("EXIT"),
 _T("ID"),_T("NAME"),_T("DESCRIPTION"),_T("SURFACE"),
 _T("EVENTCODE"),_T("STATECODE"),
 _T("FRAME"),_T("RATE"),_T("FREQ"),_T("REPEAT"), _T("VELOCITY"), _T("LOOP"),
 _T("STARTPOS"),_T("STARTROOM"),_T("GOTO"),
 NULL
};

typedef struct {
	long val;
	char *cstr;
} YYSTYPE;



#ifndef _YYGRAM_H
#define _YYGRAM_H
#define BEGIN              257
#define END                258
#define INCLUDE            259
#define CONSTANT           260
#define HERO               261
#define PLAYER             262
#define ROOM               263
#define PROPS              264
#define ITEMS              265
#define STATICOBJECTS      266
#define OBJECTS            267
#define EXITS              268
#define ANIM               269
#define OBJ                270
#define OBJECT             271
#define ITEM               272
#define EXIT               273
#define ID                 274
#define NAME               275
#define DESCRIPTION        276
#define SURFACE            277
#define EVENTCODE          278
#define STATECODE          279
#define FRAME              280
#define RATE               281
#define FREQ               282
#define REPEAT             283
#define VELOCITY           284
#define LOOP               285
#define STARTPOS           286
#define STARTROOM          287
#define GOTO               288
#define STRING             289
#define NUMBER             290
extern int yychar, yyerrflag;
#ifndef YYSCTAB
#define YYSCTAB const
#endif
extern YYSTYPE yyval, yylval;
#endif
/////////////////////////////////////
// Parser stuff

int yyparse();

CScriptParser *s_ptr;


CScriptParser::CScriptParser()
{
}

CScriptParser::~CScriptParser()
{
}

BOOL CScriptParser::Init(CController *pGame)
{
   s_ptr = this;
   m_pGame = pGame;
   m_UngetChar = 0;
   m_bErrors = FALSE;
   //
   m_room = new CG_Room;
   m_hero = new CG_Hero;
   m_player = new CG_Character;
   m_item = new CG_Item;
   m_prop = new CG_Prop;
   if( m_prop==NULL ) return FALSE; // error: out of memory
   //
   m_framerepeat = 1;
   //
   return TRUE;
};

BOOL CScriptParser::Close()
{
   delete m_room;
   delete m_hero;
   delete m_player;
   delete m_item;
   delete m_prop;
   return TRUE;
};

BOOL CScriptParser::ProcessFile(LPCTSTR Filename)
{
   ASSERT(s_ptr);
   ASSERT(AfxIsValidString(Filename));
   CApp *app = (CApp *)AfxGetApp();
   ASSERT_VALID(app);
   app->m_debug.PrintReplaceLine(_T("Parsing %s"),Filename);

   CStdioFile f, *old_ptr;
   CString s;
   s = KfxLocateFile(Filename);
   TRY
	{
      if( f.Open( s, CFile::modeRead|CFile::typeText )==FALSE ) return FALSE;
      m_sFilename = s;
      old_ptr = f_ptr;
      f_ptr = &f;
      while( yyparse()!=0 ) ;
      f.Close();
      f_ptr = old_ptr;
   }
   CATCH( CFileException, e )
   {
#ifdef _DEBUG
      e->ReportError();
#endif
      f.Abort();
      return FALSE;
   }
   END_CATCH;
   app->m_debug.PrintReplaceLine(_T("Definitions parsed."));
   return !m_bErrors;
};

static short gettoken()
{
   ASSERT_VALID( s_ptr );
   char c;
   if( s_ptr->m_UngetChar!=0 ) { 
      c = s_ptr->m_UngetChar;
      s_ptr->m_UngetChar = 0;
      return c;
   };
   if( s_ptr->f_ptr->Read(&c,1)==FALSE) return EOF;
   switch( c ) {
   case _T('\t'):
   case _T('\r'):
      // Some character are treated as blanks
      c = _T(' ');
      break;
   };
   return c;
};

static char * stringet()
// Get a complete string enclosed in quotes ( the "-char )
// NOTE: A static char-buffer is returned
{
#define MAX_STRING_LEN 256
    ASSERT_VALID( s_ptr );
    static TCHAR str[MAX_STRING_LEN];
    for ( int i=0; i < MAX_STRING_LEN; i++ ) {
        str[i] = (char)gettoken();
        switch( str[i] ) {
        case _T('"'):
        case _T('\n'):
           goto this_is_it;
        };
    }
this_is_it: ;
    str[i] = '\0';  /* mark end of string */
    return str;
}

static char * wordget(TCHAR c)
// Get a word from the file
// NOTE: Keeps a few static buffers which
// are returned
{
#define MAX_VAR_LEN 16
#define MAX_VARS 4
    ASSERT_VALID( s_ptr );
    static TCHAR var[MAX_VARS][MAX_VAR_LEN];
    static short buf = 0;
    // Get next string buffer
    buf = (buf+1) % MAX_VARS;
    // Fill buffer with chars
    var[buf][0] = c;  /* first letter obtained already */
    for ( int i=1; i < MAX_VAR_LEN; i++ ) {
        var[buf][i] = (char)gettoken();
        switch( var[buf][i] ) {
        case _T(' '):
        case _T('\n'):
           // Ignore blanks and new-lines
           goto this_is_it;
        case _T('('):
        case _T(')'):
        case _T(','):
        case _T('+'):
        case _T('-'):
        case _T('%'):
        case _T('*'):
        case _T('='):
           s_ptr->m_UngetChar = var[buf][i];
           goto this_is_it;
        };
    }
this_is_it:
    var[buf][i] = '\0';
    return var[buf];
}

static int yylex()
{
   char c;
   extern YYSTYPE yylval;
get_it: ;
   while ( (c=(char)gettoken()) == ' ' )
        /* skip blanks */;
   switch(c) {
   case _T('\n'):    /* EOL */
       goto get_it;
   case _T(','):    /* comma */
   case _T('('):    /* r paren */
   case _T(')'):    /* l paren */
   case _T('+'):    /* + */
   case _T('-'):    /* - */
   case _T('*'):    /* * */
   case _T('%'):    /* / */
   case _T('='):    /* equal */
       return c;
   case _T('/'):    /* line comment */
      gettoken();
      while( gettoken()!=_T('\n') ) ;
      goto get_it;
   case EOF:     /* end of file */
       return 0 ;
   case _T('"'):     /* start of string */
       yylval.cstr = stringet();
       return STRING;
   default:      /* keyword or name */
      yylval.cstr = wordget(c);
      // Test if it is a constant number
      if(isdigit(c)) {
         yylval.val = _ttol(yylval.cstr);
         return NUMBER;
      }
      // Check the tokens
      LPCTSTR *p = tokennames;
      int i=1;
      while( *p!=NULL  ) {
         if( stricmp( *p, yylval.cstr )==0 ) 
            return i+256; // 256 = YYERRCODE
         p++;
         i++;
      };
      // Is it a constant?
      DWORD tmp_val;
      if( s_ptr->m_pGame->GetConstant(yylval.cstr,tmp_val) ) {
         yylval.val = tmp_val;
         return NUMBER;
      }
      // Nope, none of the above... it's a simple string
      return NAME;
   }
}

static void yyerror(LPCTSTR s)
{
   CApp *app = (CApp *)AfxGetApp();
   ASSERT(s_ptr);
   ASSERT_VALID(app);
   if( !AfxIsValidString(s) ) return;
   app->m_debug.Error(_T("%s.\r\nIn File: '%s'\r\n"),s,s_ptr->m_sFilename);
   s_ptr->m_bErrors = TRUE;
}


/////////////////////////////////////
// Functions

BOOL CScriptParser::Validate()
{
#define ADDOBJ(dst,x) { \
   ASSERT(x); \
   CString tmp(x->m_sName); \
   tmp.MakeUpper(); \
   dst.SetAt( tmp, x ); \
   };

   ASSERT_VALID( m_pGame );
   int i;
   //
   // Add all objects to Global Object Map (gives quick access to ALL names)
   //
   m_pGame->m_objects.RemoveAll();
   for( i=0; i<m_pGame->m_props.GetSize(); i++ ) ADDOBJ(m_pGame->m_objects,m_pGame->m_props[i]);
   for( i=0; i<m_pGame->m_rooms.GetSize(); i++ ) ADDOBJ(m_pGame->m_objects,m_pGame->m_rooms[i]);
   for( i=0; i<m_pGame->m_items.GetSize(); i++ ) ADDOBJ(m_pGame->m_objects,m_pGame->m_items[i]);
   for( i=0; i<m_pGame->m_chars.GetSize(); i++ ) ADDOBJ(m_pGame->m_objects,m_pGame->m_chars[i]);
   m_pGame->m_liveobjects.RemoveAll();
   for( i=0; i<m_pGame->m_chars.GetSize(); i++ ) m_pGame->m_liveobjects.Add(m_pGame->m_chars[i]);
   for( i=0; i<m_pGame->m_items.GetSize(); i++ ) m_pGame->m_liveobjects.Add(m_pGame->m_items[i]);
   //
   // Validate all ROOM references
   //
   for( i=0; i<m_pGame->m_liveobjects.GetSize(); i++ ) {
      CString sName( m_pGame->m_liveobjects[i]->m_sStartRoom );
      CG_ID id = OBJ_NOTVISIBLE;
      if( sName==_T("INVENTORY") ) {
         id = OBJ_INVENTORY;
      }
      else if( !sName.IsEmpty() ) {
         CG_Room *room = m_pGame->m_objects.FindRoom(sName);
         if( room==NULL ) { yyerror("Room not found."); return FALSE; }
         id = room->m_ID;
      }
      m_pGame->m_liveobjects[i]->m_RoomID = id;
   };

   //
   // Set object size (in pixels) for all
   //
   for( i=0; i<m_pGame->m_items.GetSize(); i++ ) {
         CG_Item *item = m_pGame->m_items[i];
         item->m_size = CSize( item->m_frames[0].Width(), item->m_frames[0].Height() );
   };
   for( i=0; i<m_pGame->m_chars.GetSize(); i++ ) {
         CG_Character *player = m_pGame->m_chars[i];
         player->m_size = CSize( player->m_anims[0].Frames[0].Width(), player->m_anims[0].Frames[0].Height() );
   }

   return TRUE;
};


/////////////////////////////////////
// Yacc stuff
static YYSCTAB short  yydef[] = {
	  -1,   -5,   84,   86,   88,   92,    3,   82,   83,   85, 
	  87,   89,   90,   91,    8,    7,   12,   11,    9,    6, 
	   5,    4,   10
};
static YYSCTAB short  yyex[] = {
	   0,   93,   -1,    1,    0,    0,   -1,    1
};
static YYSCTAB short  yyact[] = {
	-185, -129, -130, -131,  260,  259,  257,  256, -128,  275, 
	-176,  289, -126, -125, -124, -127,  264,  263,  262,  261, 
	-123,   61, -122, -121,  277,  257, -119, -112, -113, -114, 
	-117, -118, -115, -116,  287,  286,  279,  278,  277,  276, 
	 275,  257, -110, -102, -103, -105, -108, -109, -104, -106, 
	-107,  287,  286,  284,  279,  278,  277,  276,  275,  257, 
	-100,  -97,  -98,  -99,  277,  276,  275,  257, -175,  290, 
	 -94,  -95,  272,  271, -148,  289,  -93,  258,  -92,  269, 
	-152,  289, -153,  289, -154,  289,  -91, -200,  290,   40, 
	-156,  289, -157,  289, -158,  289,  -89,  258,  -88,  269, 
	-162,  289, -163,  289, -164,  289, -166,  289,  -87, -200, 
	 290,   40, -167,  289, -168,  289,  -86,  258,  -83,  -84, 
	 -85,  268,  267,  266, -172,  289, -173,  289, -174,  289, 
	 -82,  258,  -76,  -77,  -80,  -81,  -79,  -78,  287,  286, 
	 280,  278,  276,  275,  -74,  -81,  280,  275, -182,  264, 
	 -70,  -81,  -71,  -72,  283,  282,  280,  275,  -67,  -66, 
	 -64,  -63,  -65,   45,   44,   43,   42,   37, -177,  261, 
	 -59,  -81,  -60,  -61,  -62,  285,  283,  282,  280,  275, 
	 -67,  -66,  -64,  -65,   45,   43,   42,   37, -178,  262, 
	 -56,  273,  -54,  270,  -52,  270, -179,  263,  -50, -200, 
	 290,   40, -139,  289, -141,  289, -142,  289, -143,  289, 
	 -48,  258, -145,  289,  -47,  258, -150,  289,  -46,  258, 
	 -67, -134,  -66,  -64,  -45,  -65,   45,   44,   43,   42, 
	  41,   37, -160,  289,  -44,  258,  -67, -134,  -66,  -64, 
	 -65,   45,   43,   42,   41,   37,  -43,  289,  -42,  258, 
	 -41,  289,  -40,  258,  -39,  289,  -38,  258,  -67,  -66, 
	 -64,  -36,  -65,   45,   44,   43,   42,   37, -146,  272, 
	-147,  271, -151,  269,  -67,  -66,   42,   37, -161,  269, 
	-189,  268, -188,  267, -187,  266,  -67, -134,  -66,  -64, 
	 -33,  -65,   45,   44,   43,   42,   41,   37,  -67, -136, 
	 -66,  -64,  -65,   45,   43,   42,   41,   37,  -67,  -66, 
	 -64,  -30,  -65,   45,   44,   43,   42,   37,  -67,  -66, 
	 -64,  -29,  -65,   45,   44,   43,   42,   37,  -67,  -66, 
	 -64,  -26,  -65,   45,   44,   43,   42,   37,  -67,  -66, 
	 -64,  -25,  -65,   45,   44,   43,   42,   37,  -67, -135, 
	 -66,  -64,  -65,   45,   43,   42,   41,   37,   -1
};
static YYSCTAB short  yypact[] = {
	   4,    8,   24,   34,   51,   64,  184,  138,  146,  154, 
	 175,  191,  193,  195,  184,  184,  276,  276,  184,  184, 
	 184,  184,  184,  353,  110,  110,  343,  333,  110,  110, 
	 323,  313,  110,   88,  303,  110,  292,  285,   88,  283, 
	  88,  281,  200,  279,  110,  273,  271,  269,  263,  110, 
	 257,  255,  253,  251,  249,  247,  241,  235,  233,  110, 
	 110,  110,  110,  110,  110,  110,  110,  226,  219,  217, 
	 110,  110,  215,  213,  211,  209,  207,  205,   88,  203, 
	 200,  197,  195,  193,  191,  189,  110,  175,  169,  163, 
	 110,  154,  149,  146,  138,  131,  129,  127,  125,  121, 
	 117,  115,  113,  110,  107,   88,  105,  103,  101,   99, 
	  97,   95,   93,   91,   88,   85,   83,   81,   79,   77, 
	  75,   72,   69,   64,   51,   34,   24,   21,   16,   11,    9
};
static YYSCTAB short  yygo[] = {
	 -24,  -23,  -27,  -28,  -31,  -32,  -49,  -35,  -37,  -22, 
	 -21,  -20,  -19,  -18,  -17, -133, -132,  -16,  -15,  -49, 
	 -57,  -68,   -7,  -90,  103,   90,   86,   80,   71,   70, 
	  66,   65,   64,   63,   62,   61,   60,   59,   49,   44, 
	  42,   35,   32,   29,   28,   25,   24,   -2,   -1, -180, 
	-186,  -96,    5, -193, -101,    4, -195, -111,    3, -197, 
	-120,    2, -183, -184,   -6, -190,  -51,   13, -191,  -53, 
	  12, -192,  -55,   11,  -14, -169, -171, -170, -140, -165, 
	-155,  105,   78,   40,   38,   33,  -13,  -12,  -34, -137, 
	  42,   -5, -194,  -58,   10,  -11, -144, -149, -159, -159, 
	-149, -144, -138,   93,   91,   87,   10,    9,    8,   -4, 
	-196,  -69,    9,  -10,   -3, -198,  -73,    8, -199,  -75, 
	   7,   -9,   -8,   -1
};
static YYSCTAB short  yypgo[] = {
	   0,    0,    0,   91,   95,   95,   95,  113,  113,   80, 
	  89,   23,   23,   23,   23,   23,   89,   80,  102,  122, 
	 122,  122,  122,  122,  122,  121,  121,  114,  114,  114, 
	 113,  113,  109,  109,  109,  109,  109,  109,  109,  109, 
	  95,   95,   91,   91,   91,   91,   91,   91,   91,   91, 
	  87,   86,   74,   64,   64,   64,   62,   63,   49,   49, 
	  49,   48,   48,   49,   49,   49,   49,   51,   64,   64, 
	  64,   66,   69,   72,   54,   93,   57,  111,   60,  116, 
	 119,   23,  119,  116,   60,  111,   57,   93,   54,   72, 
	  69,   66,   51,   47,    0
};
static YYSCTAB short  yyrlen[] = {
	   0,    0,    0,    2,    2,    2,    2,    2,    2,    3, 
	   7,    3,    3,    3,    3,    3,    9,    5,    2,    1, 
	   2,    2,    2,    2,    2,    1,    2,    5,    5,    2, 
	   1,    2,    5,    2,    2,    2,    2,    2,    2,    2, 
	   1,    2,    5,    2,    2,    2,    2,    2,    2,    2, 
	   4,    3,    3,    2,    2,    2,    4,    2,    5,    5, 
	   5,    2,    0,    5,    1,    1,    1,    2,    5,    5, 
	   5,    2,    2,    2,    2,    2,    2,    2,    2,    2, 
	   2,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    2
};
#define YYS0	180
#define YYDELTA	118
#define YYNPACT	131
#define YYNDEF	23

#define YYr92	0
#define YYr93	1
#define YYr94	2
#define YYr34	3
#define YYr44	4
#define YYr45	5
#define YYr46	6
#define YYr61	7
#define YYr62	8
#define YYr82	9
#define YYr84	10
#define YYr87	11
#define YYr88	12
#define YYr90	13
#define YYr89	14
#define YYr86	15
#define YYr85	16
#define YYr83	17
#define YYr81	18
#define YYr80	19
#define YYr79	20
#define YYr78	21
#define YYr77	22
#define YYr76	23
#define YYr75	24
#define YYr72	25
#define YYr71	26
#define YYr68	27
#define YYr67	28
#define YYr66	29
#define YYr63	30
#define YYr60	31
#define YYr57	32
#define YYr56	33
#define YYr55	34
#define YYr54	35
#define YYr53	36
#define YYr52	37
#define YYr51	38
#define YYr50	39
#define YYr47	40
#define YYr43	41
#define YYr40	42
#define YYr39	43
#define YYr38	44
#define YYr37	45
#define YYr36	46
#define YYr35	47
#define YYr33	48
#define YYr32	49
#define YYr29	50
#define YYr26	51
#define YYr23	52
#define YYr17	53
#define YYr16	54
#define YYr15	55
#define YYr12	56
#define YYr11	57
#define YYr6	58
#define YYr5	59
#define YYr4	60
#define YYrACCEPT	YYr92
#define YYrERROR	YYr93
#define YYrLR2	YYr94
/*
 * Automaton to interpret LALR(1) tables.
 *
 *	Macros available in actions:
 *		yyclearin - clear the lookahead token.
 *		yyerrok - forgive a pending error
 *		YYERROR - simulate an error
 *		YYACCEPT - halt and return 0
 *		YYABORT - halt and return 1
 *		YYRETURN(value) - halt and return value.  You should use this
 *			instead of return(value).
 *		YYREAD - ensure yychar contains a lookahead token by reading
 *			one if it does not.  See also YYSYNC.
 *
 *	Macros set by user, used internally:
 *		YYDEBUG - includes debug code.  The parser will print
 *			 a travelogue of the parse if this is defined
 *			 and yydebug is non-zero. (default undef)
 *		YYSSIZE - size of state and value stacks (default 150).
 *		YYSTATIC - By default, the state stack is an automatic array.
 *			If this is defined, the stack will be static.
 *			In either case, the value stack is static.
 *		YYALLOC - Dynamically allocate both the state and value stacks
 *			by calling malloc() and free(). If YYALLOC >= 10, the stacks 
 *			will be grown by YYALLOC elements. This means the user cannot
 *			keep pointer into the stack, if he wants to use this feature.
 *		YYLR2 - defined if lookahead is needed to resolve R/R or S/R conflicts
 *		YYSYNC - if defined, Yay guarantees to fetch a lookahead token
 *			before any action, even if it doesnt need it for a decision.
 *			If YYSYNC is defined, YYREAD will never be necessary unless
 *			the user explicitly sets yychar = -1
 *		YYSHIFT - called when a succesful shift occurs on the last value
 *			returned by yylex. Defaults to nothing.
 *
 *	Copyright (c) 1983, by the University of Waterloo
 */

#include <stdlib.h>		/* for malloc and realloc */

#ifndef YYSSIZE
	#define YYSSIZE	150
#endif
#ifndef YYSHIFT
	#define YYSHIFT	/* nothing */
#endif
#define YYERROR		goto yyerrlabel
#define yyerrok		yyerrflag = 0
#define yyclearin	yychar = -1
#define YYACCEPT	YYRETURN(0)
#define YYABORT		YYRETURN(1)
#ifdef YYALLOC
	#define YYRETURN(val)	{ yyretval = (val); goto yyReturn; }
#else
	#define YYRETURN(val)	return(val)
#endif
#ifdef YYDEBUG
	#define YYREAD	do if (yychar < 0) {									\
						if ((yychar = yylex()) < 0)							\
							yychar = 0;										\
						if (yydebug)										\
							printf("read %8s (%3d)\n", yyptok(yychar), yychar);\
					} while(0)
#else
	#define YYREAD	do if (yychar < 0) {									\
						if ((yychar = yylex()) < 0)							\
							yychar = 0;										\
					} while(0)
#endif

#ifdef YYSYNC
	#define YYSYNC_READ 1
#else
	#define YYSYNC_READ 0
#endif

#define YYERRCODE	256		/* value of `error' */

YYSTYPE	yyval,			/* $$ */
	*yypvt,				/* $n */
	yylval;				/* yylex() sets this */

int	yychar,				/* current token */
	yyerrflag,			/* error flag */
	yynerrs;			/* error count */

#ifdef YYDEBUG
	int yydebug = YYDEBUG-0;		/* debug flag & tables */
	extern YYSCTAB char	* YYSCTAB yysvar[], * YYSCTAB yystoken[];
	extern const char *yyptok(int);
	extern YYSCTAB short	yyrmap[], yysmap[];
	extern int	yynstate, yynvar, yyntoken, yynrule;
# define yyassert(condition, msg, arg) \
	if (!(condition)) { printf("\nYay bug: "); printf(msg, arg); YYABORT; }
#else /* !YYDEBUG */
# define yyassert(condition, msg, arg)
#endif

	static int
yyparse() {

	register short			yyi;	/* for table lookup */
	register YYSCTAB short *yyp;	/* for table lookup */
	register short	      *yyps;	/* top of state stack */
	register short		yystate;	/* current state */
	register YYSTYPE	  *yypv;	/* top of value stack */
	register YYSCTAB short *yyq;
	register int			yyj;
	int						yylerr = 0;

	#ifdef YYSTATIC
		static short	yys[YYSSIZE + 1];
		static YYSTYPE	yyv[YYSSIZE + 1];
	#elif defined(YYALLOC)
		YYSTYPE *yyv;
		short	*yys;
		YYSTYPE yysave_lval, yysave_val, *yysave_pvt;
		int yysave_char, yysave_errflag, yysave_nerrs;
		int yyretval;
	#else
		short			yys[YYSSIZE + 1];
		static YYSTYPE	yyv[YYSSIZE + 1];	/* historically static */
	#endif
	
	#if defined(YYALLOC) && YYALLOC-0 >= 10
		int yyssize = YYSSIZE;
	#else
		#define	yyssize		(YYSSIZE)
	#endif


	#ifdef YYALLOC
		yys = (short *) malloc((YYSSIZE + 1) * sizeof(short));
		yyv = (YYSTYPE *) malloc((YYSSIZE + 1) * sizeof(YYSTYPE));
		if (yys == (short *)0 || yyv == (YYSTYPE *)0) {
			yyerror("Not enough space for parser stacks");
			return 1;
		}
		yysave_lval = yylval;
		yysave_val = yyval;
		yysave_pvt = yypvt;
		yysave_char = yychar;
		yysave_errflag = yyerrflag;
		yysave_nerrs = yynerrs;
	#endif

	yynerrs = 0;
	yyerrflag = 0;
	yychar = -1;
	yyps = yys;
	yypv = yyv;
	yystate = YYS0;		/* start state */

  yyStack:
	yyassert((unsigned)yystate < yynstate, "state %4d\n", yystate);
	if (++yyps > &yys[yyssize]) {
		#if defined(YYALLOC) && YYALLOC-0 >= 10
			short *newyys;
			YYSTYPE *newyyv;
			newyys = (short *)realloc( (void *)yys,
				(yyssize+YYALLOC+1) * sizeof(short));
			newyyv = (YYSTYPE *) realloc((void *) yyv,
				(yyssize+YYALLOC+1) * sizeof(YYSTYPE));
			if( !newyys || !newyyv ) {
				yyerror("Parser stack overflow");
				YYABORT;
			}
			yyps = newyys + (yyps-yys);
			yypv = newyyv + (yypv-yyv);
			yys = newyys;
			yyv = newyyv;
			yyssize += YYALLOC;
		#else
			yyerror("Parser stack overflow");
			YYABORT;
		#endif
	}
	*yyps = yystate;	/* stack current state */
	*++yypv = yyval;	/* ... and value */

	#ifdef YYDEBUG
		if (yydebug)
			printf("state %4d (%4d), char %8s (%3d)\n", yysmap[yystate],
				yystate, yyptok(yychar), yychar);
	#endif

	if( 0 ) goto yyerrlabel;	/* suppress an error message */
	/*
	 *	Look up next action in action table.
	 */
  yyEncore:
	if( YYSYNC_READ ) YYREAD;

	if ((unsigned)yystate >= sizeof yypact/sizeof yypact[0]) /* simple state */
		yyi = yystate - YYDELTA;	/* reduce in any case */
	else {
		if( *(yyp = &yyact[yypact[yystate]]) >= 0 ) {
			/* Look for a shift on yychar */
			
			if( !YYSYNC_READ ) YYREAD;
			yyq = yyp;
			yyi = yychar;
			while (yyi < *yyp++);
			if (yyi == yyp[-1]) {
				yystate = ~yyq[yyq-yyp];
				#ifdef YYDEBUG
					if (yydebug)
						printf("shift %4d (%4d)\n", yysmap[yystate], yystate);
				#endif
				yyval = yylval;		/* stack what yylex() set */
				YYSHIFT;			/* Tell user about shift */
				yychar = -1;		/* clear token */
				if (yyerrflag) {
					yyerrflag--;	/* successful shift */
					yylerr = 0;		/* no restrictions on error shifts */
				}
				goto yyStack;
			}
		}

		/*
	 	 *	Fell through - take default action
	 	 */

		if ((unsigned)yystate >= sizeof yydef /sizeof yydef[0] )
			goto yyError;
		if ((yyi = yydef[yystate]) < 0)	 { /* default == reduce? */
											/* Search exception table */
			yyassert((unsigned)~yyi < sizeof yyex/sizeof yyex[0],
				"exception %d\n", yystate);
			yyp = &yyex[~yyi];

			if( !YYSYNC_READ) YYREAD;

			while( (yyi = *yyp) >= 0 && yyi != yychar)
				yyp += 2;
			yyi = yyp[1];
			yyassert(yyi >= 0,"Ex table not reduce %d\n", yyi);
		}
	}

	#ifdef YYLR2
	  yyReduce:	/* reduce yyi */
	#endif
	yyassert((unsigned)yyi < yynrule, "reduce %d\n", yyi);
	yyj = yyrlen[yyi];
	#ifdef YYDEBUG
		if (yydebug) printf("reduce %3d (%3d), pops %4d (%4d)\n", yyrmap[yyi],
			yyi, yysmap[yyps[-yyj]], yyps[-yyj]);
	#endif
	yyps -= yyj;		/* pop stacks */
	yypvt = yypv;		/* save top */
	yypv -= yyj;
	yyval = yypv[1];	/* default action $$ = $1 */
	switch (yyi) {		/* perform semantic action */
		
case YYr4: {	/* element :  BEGIN ROOM room_def_list END ROOM */

		ASSERT_VALID(s_ptr);
		ASSERT_VALID(s_ptr->m_room);
		s_ptr->m_pGame->m_rooms.Add( s_ptr->m_room );
		s_ptr->m_room = new CG_Room;
		if(s_ptr->m_room==NULL) yyerror("Out of memory");
	
} break;

case YYr5: {	/* element :  BEGIN PLAYER player_def_list END PLAYER */

		ASSERT_VALID(s_ptr);
		ASSERT_VALID(s_ptr->m_player);
		s_ptr->m_pGame->m_chars.Add( s_ptr->m_player );
		s_ptr->m_player = new CG_Character;
		if(s_ptr->m_player==NULL) yyerror("Out of memory");
	
} break;

case YYr6: {	/* element :  BEGIN HERO hero_def_list END HERO */

		static BOOL bDefined = FALSE;
		if( bDefined ) yyerror(_T("Hero already defined!"));
		bDefined = TRUE;
		ASSERT_VALID(s_ptr);
		ASSERT_VALID(s_ptr->m_hero);
		s_ptr->m_pGame->m_chars.Add( s_ptr->m_hero );
		s_ptr->m_pGame->m_current_hero = s_ptr->m_hero;
		s_ptr->m_hero = new CG_Hero;
		if(s_ptr->m_hero==NULL) yyerror("Out of memory");
	
} break;

case YYr11: {	/* include :  INCLUDE STRING */

		ASSERT_VALID(s_ptr);
		CString s(yypvt[0].cstr);
		s = KfxLocateFile(s);
		if( s.IsEmpty() ) s = BfxGetFilePath(s_ptr->m_sFilename) + CString(yypvt[0].cstr);
		s_ptr->ProcessFile(s);
		yychar = -1; // this triggers continuing the old parse-tree
	
} break;

case YYr12: {	/* const_def :  CONSTANT NAME '=' NUMBER */

		ASSERT_VALID(s_ptr);
		s_ptr->m_pGame->AddConstant(yypvt[-2].cstr,yypvt[0].val);
	
} break;

case YYr15: {	/* room_item :  NAME STRING */
 s_ptr->m_room->m_sName = yypvt[0].cstr; 
} break;

case YYr16: {	/* room_item :  DESCRIPTION STRING */
 s_ptr->m_room->m_sDescription = yypvt[0].cstr; 
} break;

case YYr17: {	/* room_item :  SURFACE STRING */
 s_ptr->m_room->m_sSurfaceName = yypvt[0].cstr; 
} break;

case YYr23: {	/* room_static_item :  OBJ STRING pos */
 
		ASSERT_VALID(s_ptr);
		CG_Prop *prop = s_ptr->m_pGame->m_props.Find(yypvt[-1].cstr);
		if( prop==NULL ) { yyerror("Room prop not found."); };
		s_ptr->m_roomobj.obj = prop;
		s_ptr->m_roomobj.pos = s_ptr->m_pos;
		s_ptr->m_room->m_staticobjects.Add(s_ptr->m_roomobj);
	
} break;

case YYr26: {	/* room_object_item :  OBJ STRING pos */
 
		ASSERT_VALID(s_ptr);
		CG_Prop *prop = s_ptr->m_pGame->m_props.Find(yypvt[-1].cstr);
		s_ptr->m_roomobj.obj = prop;
		s_ptr->m_roomobj.pos = s_ptr->m_pos;
		s_ptr->m_room->m_objects.Add(s_ptr->m_roomobj);
	
} break;

case YYr29: {	/* room_exit_item :  EXIT STRING rect pos */
 
		ASSERT_VALID(s_ptr);
		s_ptr->m_roomexit.room = yypvt[-2].cstr;
		s_ptr->m_roomexit.exitarea = s_ptr->m_rect;
		s_ptr->m_roomexit.startpos = s_ptr->m_pos;
		s_ptr->m_room->m_exits.Add(s_ptr->m_roomexit);
	
} break;

case YYr32: {	/* player_item :  NAME STRING */
 s_ptr->m_player->m_sName = yypvt[0].cstr; 
} break;

case YYr33: {	/* player_item :  DESCRIPTION STRING */
 s_ptr->m_player->m_sDescription = yypvt[0].cstr; 
} break;

case YYr34: {	/* player_item :  VELOCITY intexp */
 s_ptr->m_player->m_nVelocity = yypvt[0].val; 
} break;

case YYr35: {	/* player_item :  SURFACE STRING */
 s_ptr->m_player->m_sSurfaceName = yypvt[0].cstr; 
} break;

case YYr36: {	/* player_item :  STARTPOS pos */
 s_ptr->m_player->m_pos = s_ptr->m_pos; 
} break;

case YYr37: {	/* player_item :  STARTROOM STRING */
 s_ptr->m_player->m_sStartRoom = yypvt[0].cstr; 
} break;

case YYr38: {	/* player_item :  EVENTCODE STRING */
 s_ptr->m_player->m_sLinkEventCode = yypvt[0].cstr; 
} break;

case YYr39: {	/* player_item :  STATECODE STRING */
 s_ptr->m_player->m_sLinkStateCode = yypvt[0].cstr; 
} break;

case YYr40: {	/* player_item :  BEGIN ANIM player_anim_def_list END ANIM */

		s_ptr->m_player->m_nNumAnims++;
	
} break;

case YYr43: {	/* player_anim_item :  NAME STRING */
 CString s(yypvt[0].cstr); s.MakeUpper(); s_ptr->m_player->m_anims[s_ptr->m_player->m_nNumAnims].sName = s; 
} break;

case YYr44: {	/* player_anim_item :  FREQ intexp */
 s_ptr->m_player->m_anims[s_ptr->m_player->m_nNumAnims].nFreq = yypvt[0].val; 
} break;

case YYr45: {	/* player_anim_item :  REPEAT intexp */
 s_ptr->m_framerepeat = yypvt[0].val; 
} break;

case YYr46: {	/* player_anim_item :  LOOP intexp */
 s_ptr->m_framerepeat = yypvt[0].val; 
} break;

case YYr47: {	/* player_anim_item :  frame_item */

		ASSERT_VALID( s_ptr );
		CG_Character *player = s_ptr->m_player;
		ASSERT_VALID(player);
		player->m_anims[player->m_nNumAnims].Frames.Append( s_ptr->m_frames );
	
} break;

case YYr50: {	/* hero_item :  NAME STRING */
 s_ptr->m_hero->m_sName = yypvt[0].cstr; 
} break;

case YYr51: {	/* hero_item :  DESCRIPTION STRING */
 s_ptr->m_hero->m_sDescription = yypvt[0].cstr; 
} break;

case YYr52: {	/* hero_item :  SURFACE STRING */
 s_ptr->m_hero->m_sSurfaceName = yypvt[0].cstr; 
} break;

case YYr53: {	/* hero_item :  STARTPOS pos */
 s_ptr->m_hero->m_pos = s_ptr->m_pos; 
} break;

case YYr54: {	/* hero_item :  STARTROOM STRING */
 s_ptr->m_hero->m_sStartRoom = yypvt[0].cstr; 
} break;

case YYr55: {	/* hero_item :  EVENTCODE STRING */
 s_ptr->m_hero->m_sLinkEventCode = yypvt[0].cstr; 
} break;

case YYr56: {	/* hero_item :  STATECODE STRING */
 s_ptr->m_hero->m_sLinkStateCode = yypvt[0].cstr; 
} break;

case YYr57: {	/* hero_item :  BEGIN ANIM hero_anim_def_list END ANIM */

		s_ptr->m_hero->m_nNumAnims++;
	
} break;

case YYr60: {	/* hero_anim_item :  NAME STRING */
 CString s(yypvt[0].cstr); s.MakeUpper(); s_ptr->m_hero->m_anims[s_ptr->m_hero->m_nNumAnims].sName = s; 
} break;

case YYr61: {	/* hero_anim_item :  FREQ intexp */
 s_ptr->m_hero->m_anims[s_ptr->m_hero->m_nNumAnims].nFreq = yypvt[0].val; 
} break;

case YYr62: {	/* hero_anim_item :  REPEAT intexp */
 s_ptr->m_framerepeat = yypvt[0].val; 
} break;

case YYr63: {	/* hero_anim_item :  frame_item */

		ASSERT_VALID( s_ptr );
		CG_Character *hero = s_ptr->m_hero;
		ASSERT_VALID(hero);
		hero->m_anims[hero->m_nNumAnims].Frames.Append( s_ptr->m_frames );
	
} break;

case YYr66: {	/* items_item :  SURFACE STRING */
 CString s(yypvt[0].cstr); s.MakeUpper(); s_ptr->m_sSurfaceName = s; 
} break;

case YYr67: {	/* items_item :  BEGIN OBJECT object_def_list END OBJECT */

		ASSERT_VALID(s_ptr);
		ASSERT_VALID(s_ptr->m_prop);
		s_ptr->m_prop->m_sSurfaceName = s_ptr->m_sSurfaceName;
		s_ptr->m_pGame->m_props.Add( s_ptr->m_prop );
		//
		s_ptr->m_prop = new CG_Prop;
		if(s_ptr->m_prop==NULL) yyerror("Out of memory");
	
} break;

case YYr68: {	/* items_item :  BEGIN ITEM item_def_list END ITEM */

		ASSERT_VALID(s_ptr);
		ASSERT_VALID(s_ptr->m_item);
		s_ptr->m_item->m_sSurfaceName = s_ptr->m_sSurfaceName;
		s_ptr->m_pGame->m_items.Add(s_ptr->m_item);
		//
		s_ptr->m_item = new CG_Item;
		if(s_ptr->m_item==NULL) yyerror("Out of memory");
	
} break;

case YYr71: {	/* object_item :  NAME STRING */
 s_ptr->m_prop->m_sName = yypvt[0].cstr; 
} break;

case YYr72: {	/* object_item :  frame_item */
 s_ptr->m_prop->m_frames.Append(s_ptr->m_frames); 
} break;

case YYr75: {	/* item_item :  NAME STRING */
 s_ptr->m_item->m_sName = yypvt[0].cstr; 
} break;

case YYr76: {	/* item_item :  DESCRIPTION STRING */
 s_ptr->m_item->m_sDescription = yypvt[0].cstr; 
} break;

case YYr77: {	/* item_item :  STARTROOM STRING */
 s_ptr->m_item->m_sStartRoom = yypvt[0].cstr; 
} break;

case YYr78: {	/* item_item :  STARTPOS pos */
 s_ptr->m_item->m_pos = s_ptr->m_pos; 
} break;

case YYr79: {	/* item_item :  EVENTCODE STRING */
 s_ptr->m_item->m_sLinkEventCode = yypvt[0].cstr; 
} break;

case YYr80: {	/* item_item :  frame_item */
 s_ptr->m_item->m_frames.Append(s_ptr->m_frames); 
} break;

case YYr81: {	/* frame_item :  FRAME rect */

		ASSERT_VALID(s_ptr);
		// Construct one or more frames
		// This allows to quickly create multiple horizontal
		// frames...
		s_ptr->m_frames.RemoveAll();
		int w = s_ptr->m_rect.Width();
		while( s_ptr->m_framerepeat-- > 0 ) {
			s_ptr->m_frames.Add( s_ptr->m_rect );
			s_ptr->m_rect.left += w;
			s_ptr->m_rect.right += w;
		};
		// Default back to 1 frame creation
		s_ptr->m_framerepeat = 1;
	
} break;

case YYr82: {	/* pos :  intexp ',' intexp */
 s_ptr->m_pos = CPoint(yypvt[-2].val,yypvt[0].val); 
} break;

case YYr83: {	/* pos :  '(' intexp ',' intexp ')' */
 s_ptr->m_pos = CPoint(yypvt[-3].val,yypvt[-1].val); 
} break;

case YYr84: {	/* rect :  intexp ',' intexp ',' intexp ',' intexp */
 s_ptr->m_rect = CRect(CPoint(yypvt[-6].val,yypvt[-4].val),CSize(yypvt[-2].val,yypvt[0].val)); 
} break;

case YYr85: {	/* rect :  '(' intexp ',' intexp ',' intexp ',' intexp ')' */
 s_ptr->m_rect = CRect(CPoint(yypvt[-7].val,yypvt[-5].val),CSize(yypvt[-3].val,yypvt[-1].val)); 
} break;

case YYr86: {	/* intexp :  '(' intexp ')' */
 yyval.val = yypvt[-1].val; 
} break;

case YYr87: {	/* intexp :  intexp '+' intexp */
 yyval.val = yypvt[-2].val + yypvt[0].val; 
} break;

case YYr88: {	/* intexp :  intexp '-' intexp */
 yyval.val = yypvt[-2].val - yypvt[0].val; 
} break;

case YYr89: {	/* intexp :  intexp '*' intexp */
 yyval.val = yypvt[-2].val * yypvt[0].val; 
} break;

case YYr90: {	/* intexp :  intexp '%' intexp */
 if( yypvt[0].val==0 ) yyerror("Division by zero!"); else yyval.val = yypvt[-2].val / yypvt[0].val; 
} break;

	case YYrACCEPT:
		YYACCEPT;
	case YYrERROR:
		yystate = *--yyps;
		yypv--;
		goto yyError;
	#ifdef YYLR2
		case YYrLR2:
			if( !YYSYNC_READ) YYREAD;
			yyj = 0;
			while( yylr2[yyj] >= 0 ) {
				if( yylr2[yyj] == yystate && yylr2[yyj+1] == yychar
					&& yylook(yys+1,yyps,yystate,yychar,yy2lex(),yylr2[yyj+2]) )
						break;
				yyj += 3;
			}
			if( yylr2[yyj] < 0 )
				goto yyError;
			if( yylr2[yyj+2] < 0 ) {
				yystate = ~ yylr2[yyj+2];
				goto yyStack;
			}
			yyi = yylr2[yyj+2];
			goto yyReduce;
	#endif
	}

	/*
	 *	Look up next state in goto table.
	 */

	yyp = &yygo[yypgo[yyi]];
	yyq = yyp++;
	yyi = *yyps;
	do
		;
	while (yyi < *yyp++);
	yystate = ~(yyi == *--yyp? yyq[yyq-yyp]: *yyq);
	goto yyStack;

  yyerrlabel:
	#pragma used yyerrlabel			/* from YYERROR */
	yyerrflag = 1;
  yyError:

	switch (yyerrflag) {

		default:		/* new error */
			yynerrs++;
			yyi = yychar;
			yyerror("Syntax error");
			if (yyi != yychar) {
				/* user has changed the current token */
				/* try again */
				yynerrs--;	/* assume not really an error */
				#ifdef YYDEBUG
					if( yydebug )
						printf("yychar changed from %8s (%3d) to %8s (%3d)\n",
							yyptok(yyi), yyi, yyptok(yychar), yychar);
				#endif
				goto yyEncore;
			}

		case 1:		/* partially recovered */
		case 2:
			yyerrflag = 3;	/* need 3 valid shifts to recover */
			
			/*
			 *	Pop states, looking for a
			 *	shift on `error'.
			 */

			for ( ; yyps > yys; yyps--, yypv--) {
				if ((size_t)*yyps >= sizeof yypact/sizeof yypact[0])
					continue;
				yyp = &yyact[yypact[*yyps]];
				yyq = yyp;
				do
					;
				while (YYERRCODE < *yyp++);
				if (YYERRCODE == yyp[-1] && yylerr != ~yyq[yyq-yyp] ) {
					yylerr = yystate = ~yyq[yyq-yyp];
					goto yyStack;
				}
				
				/* no shift in this state */
				#ifdef YYDEBUG
					if (yydebug && yyps > yys+1)
						printf("Error recovery pops state %4d (%4d),"
								" uncovers %4d (%4d)\n",
							yysmap[yyps[0]], yyps[0],
							yysmap[yyps[-1]], yyps[-1]);
				#endif
				/* pop stacks; try again */
			}
			/* no shift on error - abort */
			break;

		case 3:
			/*
			 *	Erroneous token after
			 *	an error - discard it.
			 */

			if (yychar == 0)  /* but not EOF */
				break;
			#ifdef YYDEBUG
				if (yydebug)
					printf("Error recovery discards %8s (%3d), ",
						yyptok(yychar), yychar);
			#endif
			yyclearin;
			goto yyEncore;	/* try again in same state */
	}
	YYABORT;

	#ifdef YYALLOC
	  yyReturn:
		yylval = yysave_lval;
		yyval = yysave_val;
		yypvt = yysave_pvt;
		yychar = yysave_char;
		yyerrflag = yysave_errflag;
		yynerrs = yysave_nerrs;
		free((char *)yys);
		free((char *)yyv);
		return(yyretval);
	#endif
}

#ifdef YYLR2

static int yylook(s,rsp,state,c1,c2,i)
	short *s;							/* stack				*/
	short *rsp;							/* real top of stack	*/
	int state;							/* current state		*/
	int c1;								/* current char			*/
	int c2;								/* next char			*/
	int i;								/* action S < 0, R >= 0	*/
{
	int j;
	short *p,*q;
	short *sb,*st;
	#ifdef YYDEBUG
		if( yydebug ) {
			printf("LR2 state %4d (%4d) char %8s (%3d) lookahead %8s (%3d)",
				yysmap[state],state,yyptok(c1),c1,yyptok(c2),c2);
			if( i > 0 )
				printf( "reduce %3d (%3d)\n", yyrmap[i], i);
			else
				printf( "shift %4d (%4d)\n", yysmap[i], i);
		}
	#endif
	st = sb = rsp+1;
	if( i >= 0 ) goto reduce;
  shift:
	state = ~i;
	c1 = c2;
	if( c1 < 0 ) return 1;
	c2 = -1;

  stack:
  	if( ++st >= &s[yyssize] ) {
		yyerror("Parser Stack Overflow");
		return 0;
	}
	*st = state;
	if( (unsigned)state >= sizeof yypact/sizeof yypact[0] )
		i = state- YYDELTA;
	else {
		p = &yyact[yypact[state]];
		q = p;
		i = c1;
		while( i < *p++ );
		if( i == p[-1] ) {
			state = ~q[q-p];
			c1 = c2;
			if( c1 < 0 ) return 1;
			c2 = -1;
			goto stack;
		}
		if( (unsigned)state >= sizeof yydef/sizeof yydef[0] )
			return 0
		if( (i = yydef[state]) < 0 ) {
			p = &yyex[~i];
			while( (i = *p) >= 0 && i != c1)
				p += 2;
			i = p[1];
		}
	}
  reduce:
  	j = yyrlen[i];
	if( st-sb >= j )
		st -= j;
	else {
		rsp -= j+st-sb;
		st = sb;
	}
	switch( i ) {
	  case YYrERROR:
		return 0;
	  case YYrACCEPT:
		return 1;
	  case YYrLR2:
		j = 0;
		while( yylr2[j] >= 0 ) {
			if( yylr2[j] == state && yylr2[j+1] == c1 )
				if( (i = yylr2[j+2]) < 0 )
					goto shift;
				else
					goto reduce;
		}
		return 0;
	}
	p = &yygo[yypgo[i]];
	q = p++;
	i = st==sb ? *rsp : *st;
	while( i < *p++ );
	state = ~( i == *--p? q[q-p]: *q);
	goto stack;
}
#endif
		
#ifdef YYDEBUG
	
	/*
	 *	Print a token legibly.
	 *	This won't work if you roll your own token numbers,
	 *	but I've found it useful.
	 */

	const char *
yyptok(int i) {
	static char	buf[10];

	if (i >= YYERRCODE)
		return yystoken[i-YYERRCODE];
	if (i < 0)
		return "";
	if (i == 0)
		return "$end";
	if (i < ' ')
		sprintf(buf, "'^%c'", i+'@');
	else
		sprintf(buf, "'%c'", i);
	return buf;
}
#endif
#ifdef YYDEBUG
 YYSCTAB char * YYSCTAB yystoken[] = {
	"error",
	"BEGIN",
	"END",
	"INCLUDE",
	"CONSTANT",
	"HERO",
	"PLAYER",
	"ROOM",
	"PROPS",
	"ITEMS",
	"STATICOBJECTS",
	"OBJECTS",
	"EXITS",
	"ANIM",
	"OBJ",
	"OBJECT",
	"ITEM",
	"EXIT",
	"ID",
	"NAME",
	"DESCRIPTION",
	"SURFACE",
	"EVENTCODE",
	"STATECODE",
	"FRAME",
	"RATE",
	"FREQ",
	"REPEAT",
	"VELOCITY",
	"LOOP",
	"STARTPOS",
	"STARTROOM",
	"GOTO",
	"STRING",
	"NUMBER",
	0
};
 YYSCTAB char * YYSCTAB yysvar[] = {
	"$accept",
	"intexp",
	"script",
	"elementlist",
	"element",
	"room_def_list",
	"player_def_list",
	"hero_def_list",
	"items_def_list",
	"const_def",
	"include",
	"room_item",
	"room_static_def_list",
	"room_object_def_list",
	"room_exit_def_list",
	"room_static_item",
	"pos",
	"room_object_item",
	"room_exit_item",
	"rect",
	"player_item",
	"player_anim_def_list",
	"player_anim_item",
	"frame_item",
	"hero_item",
	"hero_anim_def_list",
	"hero_anim_item",
	"items_item",
	"object_def_list",
	"item_def_list",
	"object_item",
	"item_item",
	0
};
 YYSCTAB short  yyrmap[] = {
	  92,   93,   94,   34,   44,   45,   46,   61,   62,   82, 
	  84,   87,   88,   90,   89,   86,   85,   83,   81,   80, 
	  79,   78,   77,   76,   75,   72,   71,   68,   67,   66, 
	  63,   60,   57,   56,   55,   54,   53,   52,   51,   50, 
	  47,   43,   40,   39,   38,   37,   36,   35,   33,   32, 
	  29,   26,   23,   17,   16,   15,   12,   11,    6,    5, 
	   4,    2,    3,    7,    8,    9,   10,   14,   18,   19, 
	  20,   22,   25,   28,   31,   42,   49,   59,   65,   70, 
	  74,   91,   73,   69,   64,   58,   48,   41,   30,   27, 
	  24,   21,   13,    1,    0
};
 YYSCTAB short  yysmap[] = {
	   1,    2,   19,   29,   40,   46,   74,   94,   98,  105, 
	 119,  124,  127,  130,  146,  147,  155,  156,  157,  158, 
	 159,  160,  197,  198,  196,  195,  194,  193,  192,  191, 
	 190,  187,  186,  180,  178,  174,  173,  172,  170,  169, 
	 167,  166,  164,  163,  152,  150,  145,  142,  134,  133, 
	 131,  129,  128,  126,  125,  123,  121,  120,  118,  117, 
	 116,  115,  112,  111,  110,  109,  108,  107,  106,  104, 
	 103,  102,   99,   97,   95,   93,   92,   91,   90,   89, 
	  87,   86,   81,   80,   79,   78,   73,   67,   66,   60, 
	  59,   54,   53,   50,   49,   47,   45,   44,   43,   42, 
	  41,   39,   38,   37,   36,   35,   34,   33,   32,   31, 
	  30,   28,   27,   26,   25,   24,   23,   22,   21,   20, 
	  18,   17,   16,   15,   14,   13,   12,   10,    8,    4, 
	   3,  153,  154,  151,  199,  188,  135,   88,  136,  137, 
	 138,  139,  140,   96,  143,  175,  176,   51,  101,  148, 
	 177,   55,   56,   57,   61,   62,   63,   64,  114,  161, 
	 179,   68,   69,   70,   71,   72,   75,   76,  189,  182, 
	 184,   82,   83,   84,   48,   11,  113,  122,  132,    9, 
	   0,  100,    7,    6,    5,   85,  185,  183,  181,  171, 
	 168,  165,   77,  162,   65,  149,   52,  144,  141,   58
};
int yyntoken = 44, yynvar = 32, yynstate = 200, yynrule = 95;
#endif
